# 📍main topic : 데이터베이스 clustered index vs non-clustered index에 대해 설명하시오


## 클러스터링 인덱스(Clustering Index)란?
```
cluster : 군집
clustering : 여러개를 하나로 묶는 행위
```
`DB`에서 `clustering` 이란 어떤 기준에 의하여 묶어 <u>저장</u>됨을 의미한다. 즉, 특정 인덱스가
데이터의 저장위치에 관여하게 되는 것이다. 이때 특정 인덱스를 `Clustering Index`라고 부른다.
한 테이블이 클러스터링 인덱스에 의해 정렬되어 저장된 경우에 클러스터링 테이블이라고 한다.

![clutster_table.jpg](..%2Fimg%2Fclutster_table.jpg)

클러스터링 테이블은 세컨더리 인덱스의 `b - tree`구조와 유사한 형태를 취하지만 가장 다른점은
리프 노드에 레코드의 모든 칼럼이 같이 저장 되어있다. 레코드는 클러스터링 인덱스에 의해 정렬 되어 저장되므로
군집화를 이루게 된다.

클러스터링 인덱스는 주로 테이블에 선언하는 `PK` 컬럼이다. 여기서 `주로`라고 말한 것은,
프라이머리키가 존재하지 않는 테이블이 있기 때문이다. 이때는 `DB`에서 정하는 규칙으로 클러스터링 
인덱스를 결정한다.
> 클러스터링 인덱스를 프라이머리키 라고 그냥 표기하기도 한다

### 클러스터링 인덱스의 결정(`Mysql` 기준)
+ 프라이머리 키가 있으면 기본적으로 프라이머리 키가 클러스터링 인덱스가 된다.
+ `Not Null`, `Unique` 인덱스 중에서 **첫번째** 인덱스를 클러스터링 키로 선택
+ 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후 클러스터링 키로 선택

### 특징
+ 테이블 당 1개만 허용한다.
+ 프라이머리 키 기반의 검색이 매우 빠르다. (`b tree` 기반으로 정렬되어 있으므로)
+ 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다.
+ pk 값이 클수록 세컨더리 인덱스의 크기가 커짐(`PK`값을 가지고 있으므로)

> 여기서 말하는 레코드의 저장이란 프라이머리 키가 증가하는 형태의 숫자가 아닌 직접 특정 컬럼을 
> pk로 지정할 떄 그렇다는 말이다. (매번 해당 Pk가 들어가야할 위치를 찾고 그에 따라 다른 레코드들의 저장위치
> 를 변경해야하므로)


## non-clustered index
데이터의 물리적인 저장순서와 상관없는 인덱스이다. 하나의 테이블에 여러개의 `non-clustered index`를
적용할 수 있으며, 클러스터링 테이블에 `non-clustered index`적용시 리프노드에는 
인덱스와 클러스터링 인덱스를 포함하게된다. 
> 힙구조에서 Non clustered index는 리프노드에 인덱스 키값 + RID(row id)의 형태를 취하게 된다.

따라서 실제 데이터에 접근하기위해 클러스터링 테이블을 거쳐야하므로 검색 속도는 느리지만 데이터의 변경면에서는
빠르다.





